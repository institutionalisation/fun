/* Definitions for POSIX memory map interface.  Linux/x86_64 version.
   Copyright (C) 2001-2018 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/* The following definitions basically come from the kernel headers.
   But the kernel header is not namespace clean.  */

/* Other flags.  */
#ifdef __USE_MISC
const u MAP_32BIT= 0x40;    /* Only give out 32-bit addresses.  */
#endif

/* These are Linux-specific.  */
#ifdef __USE_MISC
const u MAP_GROWSDOWN= 0x00100;   /* Stack-like segment.  */
const u MAP_DENYWRITE= 0x00800;   /* ETXTBSY */
const u MAP_EXECUTABLE= 0x01000;   /* Mark it as an executable.  */
const u MAP_LOCKED= 0x02000;   /* Lock the mapping.  */
const u MAP_NORESERVE= 0x04000;   /* Don't check for reservations.  */
const u MAP_POPULATE= 0x08000;   /* Populate (prefault) pagetables.  */
const u MAP_NONBLOCK= 0x10000;   /* Do not block on IO.  */
const u MAP_STACK= 0x20000;   /* Allocation is for a stack.  */
const u MAP_HUGETLB= 0x40000;   /* Create huge page mapping.  */
#endif

/* Protections are chosen from these bits, OR'd together.  The
   implementation does not necessarily support PROT_EXEC or PROT_WRITE
   without PROT_READ.  The only guarantees are that no writing will be
   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */

const u PROT_READ= 0x1;   /* Page can be read.  */
const u PROT_WRITE= 0x2;   /* Page can be written.  */
const u PROT_EXEC= 0x4;   /* Page can be executed.  */
const u PROT_NONE= 0x0;   /* Page can not be accessed.  */
const u PROT_GROWSDOWN= 0x01000000;  /* Extend change to start of
             growsdown vma (mprotect only).  */
const u PROT_GROWSUP= 0x02000000;  /* Extend change to start of
             growsup vma (mprotect only).  */

/* Sharing types (must choose one and only one of these).  */
const u MAP_SHARED= 0x01;    /* Share changes.  */
const u MAP_PRIVATE= 0x02;    /* Changes are private.  */
#ifdef __USE_MISC
const u MAP_TYPE= 0x0f;    /* Mask for type of mapping.  */
#endif

/* Other flags.  */
const u MAP_FIXED= 0x10;    /* Interpret addr exactly.  */
#ifdef __USE_MISC
const u MAP_FILE= 0;
# ifdef __MAP_ANONYMOUS
const u MAP_ANONYMOUS= __MAP_ANONYMOUS; /* Don't use a file.  */
# else
const u MAP_ANONYMOUS= 0x20;    /* Don't use a file.  */
# endif
const u MAP_ANON= MAP_ANONYMOUS;
/* When MAP_HUGETLB is set bits [26:31] encode the log2 of the huge page size.  */
const u MAP_HUGE_SHIFT= 26;
const u MAP_HUGE_MASK= 0x3f;
#endif

/* Flags to `msync'.  */
const u MS_ASYNC= 1;   /* Sync memory asynchronously.  */
const u MS_SYNC= 4;   /* Synchronous memory sync.  */
const u MS_INVALIDATE= 2;   /* Invalidate the caches.  */

/* Flags for `mremap'.  */
#ifdef __USE_GNU
const u MREMAP_MAYMOVE= 1;
const u MREMAP_FIXED= 2;
#endif

/* Advice to `madvise'.  */
#ifdef __USE_MISC
const u MADV_NORMAL= 0; /* No further special treatment.  */
const u MADV_RANDOM= 1; /* Expect random page references.  */
const u MADV_SEQUENTIAL= 2; /* Expect sequential page references.  */
const u MADV_WILLNEED= 3; /* Will need these pages.  */
const u MADV_DONTNEED= 4; /* Don't need these pages.  */
const u MADV_FREE= 8; /* Free pages only if memory pressure.  */
const u MADV_REMOVE= 9; /* Remove these pages and resources.  */
const u MADV_DONTFORK= 10;  /* Do not inherit across fork.  */
const u MADV_DOFORK= 11;  /* Do inherit across fork.  */
const u MADV_MERGEABLE= 12;  /* KSM may merge identical pages.  */
const u MADV_UNMERGEABLE= 13;  /* KSM may not merge identical pages.  */
const u MADV_HUGEPAGE= 14;  /* Worth backing with hugepages.  */
const u MADV_NOHUGEPAGE= 15;  /* Not worth backing with hugepages.  */
const u MADV_DONTDUMP= 16;    /* Explicity exclude from the core dump,
                                   overrides the coredump filter bits.  */
const u MADV_DODUMP= 17;  /* Clear the MADV_DONTDUMP flag.  */
const u MADV_WIPEONFORK= 18;  /* Zero memory on fork, child only.  */
const u MADV_KEEPONFORK= 19;  /* Undo MADV_WIPEONFORK.  */
const u MADV_HWPOISON= 100; /* Poison a page for testing.  */
#endif

/* The POSIX people had to invent similar names for the same things.  */
#ifdef __USE_XOPEN2K
const u POSIX_MADV_NORMAL= 0; /* No further special treatment.  */
const u POSIX_MADV_RANDOM= 1; /* Expect random page references.  */
const u POSIX_MADV_SEQUENTIAL= 2; /* Expect sequential page references.  */
const u POSIX_MADV_WILLNEED= 3; /* Will need these pages.  */
const u POSIX_MADV_DONTNEED= 4; /* Don't need these pages.  */
#endif

/* Flags for `mlockall'.  */
#ifndef MCL_CURRENT
const u MCL_CURRENT= 1;   /* Lock all currently mapped pages.  */
const u MCL_FUTURE= 2;   /* Lock all additions to address
             space.  */
const u MCL_ONFAULT= 4;   /* Lock all pages that are
             faulted in.  */
#endif

const u O_RDONLY= 0x0000;
const u O_WRONLY= 0x0001;
const u O_RDWR= 0x0002;
const u O_ACCMODE= 0x0003;

const u O_BINARY= 0x0004;  /* must fit in char, reserved by dos */
const u O_TEXT= 0x0008;  /* must fit in char, reserved by dos */
const u O_NOINHERIT= 0x0080;  /* DOS-specific */

const u O_CREAT= 0x0100;  /* second byte, away from DOS bits */
const u O_EXCL= 0x0200;
const u O_NOCTTY= 0x0400;
const u O_TRUNC= 0x0800;
const u O_APPEND= 0x1000;
const u O_NONBLOCK= 0x2000;